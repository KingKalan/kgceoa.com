<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Auto‑Tile Path Editor (8×8, 64×64, 16‑bitmask)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #111827;
      color: #e5e7eb;
      font-family: system-ui, sans-serif;
      display: flex;
      height: 100vh;
    }
    #sidebar {
      width: 260px;
      background: #020617;
      border-right: 1px solid #1f2937;
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #main {
      flex: 1;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    h1 {
      margin: 0;
      font-size: 18px;
      color: #f9fafb;
    }
    small { color: #9ca3af; font-size: 11px; }
    fieldset {
      border: 1px solid #374151;
      border-radius: 6px;
      padding: 8px 10px 10px;
    }
    legend {
      padding: 0 4px;
      font-size: 11px;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: .03em;
    }
    label { font-size: 13px; }
    input[type="number"] {
      width: 70px;
      padding: 2px 4px;
      margin-right: 4px;
      border-radius: 4px;
      border: 1px solid #4b5563;
      background: #111827;
      color: #e5e7eb;
    }
    input[type="range"] {
      width: 100%;
      accent-color: #f472b6;
    }
    button {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #4b5563;
      background: #111827;
      color: #e5e7eb;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover { background: #1f2937; }
    button.selected { outline: 2px solid #f472b6; }
    #modeButtons { display: flex; gap: 6px; margin-top: 6px; }
    #canvasWrapper {
      flex: 1;
      border: 1px solid #374151;
      background: #000;
      overflow: auto;
    }
    #mapCanvas {
      display: block;
      image-rendering: pixelated;
      background: #f9fafb;
    }
    #exportArea {
      width: 100%;
      height: 140px;
      box-sizing: border-box;
      background: #020617;
      color: #e5e7eb;
      border-radius: 4px;
      border: 1px solid #374151;
      font-family: monospace;
      font-size: 11px;
      padding: 6px;
      resize: vertical;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <div>
      <h1>Auto‑Tile Paths</h1>
      <small>
        8×8 tiles, up to 64×64.<br>
        Paint where the path is; each tile gets a 4‑bit NESW mask (0‑15).<br>
        The preview uses an auto‑tile pattern so edges/corners react to neighbours.
      </small>
    </div>

    <fieldset>
      <legend>Map Size</legend>
      <div>
        <label>Width:
          <input type="number" id="widthInput" min="1" max="64" value="32">
        </label>
      </div>
      <div style="margin-top:4px;">
        <label>Height:
          <input type="number" id="heightInput" min="1" max="64" value="32">
        </label>
      </div>
      <div style="margin-top:6px;">
        <button id="newMapBtn">New Map</button>
      </div>
      <small>Clears all path data.</small>
    </fieldset>

    <fieldset>
      <legend>Paint</legend>
      <div id="modeButtons">
        <button id="paintBtn" class="selected">Paint Path</button>
        <button id="eraseBtn">Erase</button>
      </div>
      <small>Left‑click / drag to paint. Right‑click = erase.</small>
    </fieldset>

    <fieldset>
      <legend>Zoom</legend>
      <input type="range" id="zoomSlider" min="1" max="6" value="4">
      <small>Controls on‑screen size of each 8×8 tile.</small>
    </fieldset>

    <fieldset>
      <legend>Export / Import</legend>
      <div style="display:flex; gap:4px; margin-bottom:6px;">
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn">Import JSON</button>
      </div>
      <textarea id="exportArea" spellcheck="false"></textarea>
      <small>
        Format:<br>
        { "width", "height", "tiles": [mask0, mask1, ...] }<br>
        mask = bit0 N, bit1 E, bit2 S, bit3 W.
      </small>
    </fieldset>
  </div>

  <div id="main">
    <div id="canvasWrapper">
      <canvas id="mapCanvas"></canvas>
    </div>
  </div>

  <script>
    // --- Constants ---
    const MAX_TILES   = 64;
    const TILE_PIXELS = 8;         // logical tile size
    const QUARTER     = 4;         // 4×4 quarter blocks inside each tile
    const GRID_COLOR  = '#f472b6';
    const BG_COLOR    = '#ffffff';
    const PATH_COLOR  = '#fb2775';

    // --- State ---
    let mapWidth  = 32;
    let mapHeight = 32;
    let zoom      = 4;             // pixels per logical pixel
    let isPathMap = [];            // [y][x] 0/1
    let maskMap   = [];            // [y][x] 0‑15 NESW bitmask
    let paintMode = 'paint';       // 'paint' | 'erase'

    // --- DOM ---
    const widthInput   = document.getElementById('widthInput');
    const heightInput  = document.getElementById('heightInput');
    const newMapBtn    = document.getElementById('newMapBtn');
    const zoomSlider   = document.getElementById('zoomSlider');
    const paintBtn     = document.getElementById('paintBtn');
    const eraseBtn     = document.getElementById('eraseBtn');
    const exportBtn    = document.getElementById('exportBtn');
    const importBtn    = document.getElementById('importBtn');
    const exportArea   = document.getElementById('exportArea');
    const canvas       = document.getElementById('mapCanvas');
    const ctx          = canvas.getContext('2d');

    // --- Helper: allocate arrays ---
    function allocMaps(w, h) {
      isPathMap = [];
      maskMap   = [];
      for (let y = 0; y < h; y++) {
        const rowPath = new Array(w).fill(0);
        const rowMask = new Array(w).fill(0);
        isPathMap.push(rowPath);
        maskMap.push(rowMask);
      }
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function resizeCanvas() {
      const tileScreen = TILE_PIXELS * zoom;
      canvas.width  = mapWidth  * tileScreen;
      canvas.height = mapHeight * tileScreen;
    }

    // --- Bitmask computation (NESW) ---
    function computeMask(x, y) {
      if (!isPathMap[y][x]) return 0;
      let mask = 0;
      if (y > 0 && isPathMap[y-1][x])           mask |= 1; // N
      if (x < mapWidth-1 && isPathMap[y][x+1])  mask |= 2; // E
      if (y < mapHeight-1 && isPathMap[y+1][x]) mask |= 4; // S
      if (x > 0 && isPathMap[y][x-1])           mask |= 8; // W
      return mask;
    }

    function updateMasksAround(x, y) {
      const coords = [
        [x, y],
        [x, y-1],
        [x+1, y],
        [x, y+1],
        [x-1, y]
      ];
      for (const [cx, cy] of coords) {
        if (cx < 0 || cy < 0 || cx >= mapWidth || cy >= mapHeight) continue;
        maskMap[cy][cx] = computeMask(cx, cy);
      }
    }

    // --- Quarter‑tile masks (borrowed from your layered auto‑tile painter) ---
    const quarterMasks = []; // [corner][state] → 4×4 offscreen canvas
    // corner: 0=TL,1=TR,2=BL,3=BR
    // state: 0=outer corner, 1/2=edge, 3=inner corner, 4=full

    function createQuarterMasks() {
      const S = QUARTER;
      for (let corner = 0; corner < 4; corner++) {
        quarterMasks[corner] = [];
        for (let state = 0; state < 5; state++) {
          const c = document.createElement('canvas');
          c.width = S;
          c.height = S;
          const cx = c.getContext('2d');
          cx.fillStyle = '#fff';

          if (state === 4) {
            cx.fillRect(0, 0, S, S); // full
          } else if (state === 0) {
            // outer corner – simple 90° wedge
            cx.beginPath();
            if (corner === 0) { // TL
              cx.moveTo(0, S); cx.lineTo(0, 0); cx.lineTo(S, 0); cx.closePath();
            } else if (corner === 1) { // TR
              cx.moveTo(0, 0); cx.lineTo(S, 0); cx.lineTo(S, S); cx.closePath();
            } else if (corner === 2) { // BL
              cx.moveTo(0, 0); cx.lineTo(0, S); cx.lineTo(S, S); cx.closePath();
            } else { // BR
              cx.moveTo(S, 0); cx.lineTo(S, S); cx.lineTo(0, S); cx.closePath();
            }
            cx.fill();
          } else if (state === 1 || state === 2) {
            // edge – full quarter minus a cut on one side
            cx.fillRect(0, 0, S, S);
            cx.globalCompositeOperation = 'destination-out';
            cx.fillStyle = '#000';
            const cut = Math.floor(S/2);
            if (corner === 0) {
              if (state === 1) cx.fillRect(0, 0, S, cut);      // trim top
              else              cx.fillRect(0, 0, cut, S);      // trim left
            } else if (corner === 1) {
              if (state === 1) cx.fillRect(0, 0, S, cut);      // trim top
              else              cx.fillRect(S-cut, 0, cut, S); // trim right
            } else if (corner === 2) {
              if (state === 1) cx.fillRect(0, S-cut, S, cut);  // trim bottom
              else              cx.fillRect(0, 0, cut, S);     // trim left
            } else {
              if (state === 1) cx.fillRect(0, S-cut, S, cut);  // trim bottom
              else              cx.fillRect(S-cut, 0, cut, S); // trim right
            }
            cx.globalCompositeOperation = 'source-over';
          } else if (state === 3) {
            // inner corner – full, then punch small quarter
            cx.fillRect(0, 0, S, S);
            cx.globalCompositeOperation = 'destination-out';
            const r = Math.floor(S/2);
            if (corner === 0) cx.fillRect(0, 0, r, r);
            else if (corner === 1) cx.fillRect(S-r, 0, r, r);
            else if (corner === 2) cx.fillRect(0, S-r, r, r);
            else cx.fillRect(S-r, S-r, r, r);
            cx.globalCompositeOperation = 'source-over';
          }
          quarterMasks[corner][state] = c;
        }
      }
    }

    // cardinalA/cardinalB/diagonal → 0..4
    function getQuarterState(cardinalA, cardinalB, diagonal) {
      if (!cardinalA && !cardinalB) return 0;                // outside corner
      if (cardinalA && !cardinalB)  return 1;                // edge A
      if (!cardinalA && cardinalB)  return 2;                // edge B
      if (cardinalA && cardinalB && !diagonal) return 3;     // inner corner
      return 4;                                              // full
    }

    // --- Drawing one tile using quarter auto‑tile + mask awareness ---
    function drawPathTile(tx, ty) {
      const mask = maskMap[ty][tx];
      if (!mask) return;

      const tileScreen = TILE_PIXELS * zoom;
      const x0 = tx * tileScreen;
      const y0 = ty * tileScreen;

      // look at neighbours (path or not)
      const n  = (ty > 0)             ? isPathMap[ty-1][tx] : 0;
      const s  = (ty < mapHeight-1)   ? isPathMap[ty+1][tx] : 0;
      const w  = (tx > 0)             ? isPathMap[ty][tx-1] : 0;
      const e  = (tx < mapWidth-1)    ? isPathMap[ty][tx+1] : 0;
      const nw = (ty > 0 && tx > 0)                   ? isPathMap[ty-1][tx-1] : 0;
      const ne = (ty > 0 && tx < mapWidth-1)          ? isPathMap[ty-1][tx+1] : 0;
      const sw = (ty < mapHeight-1 && tx > 0)         ? isPathMap[ty+1][tx-1] : 0;
      const se = (ty < mapHeight-1 && tx < mapWidth-1)? isPathMap[ty+1][tx+1] : 0;

      // Quarter states in order: TL, TR, BL, BR
      const states = [
        getQuarterState(n, w, nw),
        getQuarterState(n, e, ne),
        getQuarterState(s, w, sw),
        getQuarterState(s, e, se)
      ];

      const quarterScreen = QUARTER * zoom;
      const positions = [
        [0, 0],                    // TL
        [quarterScreen, 0],        // TR
        [0, quarterScreen],        // BL
        [quarterScreen, quarterScreen] // BR
      ];

      ctx.imageSmoothingEnabled = false;
      for (let q = 0; q < 4; q++) {
        const state = states[q];
        const maskCanvas = quarterMasks[q][state];
        if (!maskCanvas) continue;

        // temp canvas filled with PATH_COLOR, then masked
        const temp = document.createElement('canvas');
        temp.width = QUARTER;
        temp.height = QUARTER;
        const tctx = temp.getContext('2d');

        tctx.fillStyle = PATH_COLOR;
        tctx.fillRect(0, 0, QUARTER, QUARTER);
        tctx.globalCompositeOperation = 'destination-in';
        tctx.drawImage(maskCanvas, 0, 0);
        tctx.globalCompositeOperation = 'source-over';

        const [ox, oy] = positions[q];
        ctx.drawImage(temp, x0 + ox, y0 + oy, quarterScreen, quarterScreen);
      }
    }

    function drawGrid() {
      const tileScreen = TILE_PIXELS * zoom;
      ctx.strokeStyle = GRID_COLOR;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= mapWidth; x++) {
        const px = x * tileScreen + 0.5;
        ctx.moveTo(px, 0);
        ctx.lineTo(px, canvas.height);
      }
      for (let y = 0; y <= mapHeight; y++) {
        const py = y * tileScreen + 0.5;
        ctx.moveTo(0, py);
        ctx.lineTo(canvas.width, py);
      }
      ctx.stroke();
    }

    function renderAll() {
      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          if (maskMap[y][x]) drawPathTile(x, y);
        }
      }
      drawGrid();
    }

    function tileFromEvent(ev) {
      const rect = canvas.getBoundingClientRect();
      const sx = canvas.width / rect.width;
      const sy = canvas.height / rect.height;
      const px = (ev.clientX - rect.left) * sx;
      const py = (ev.clientY - rect.top) * sy;
      const tileScreen = TILE_PIXELS * zoom;
      const tx = Math.floor(px / tileScreen);
      const ty = Math.floor(py / tileScreen);
      if (tx < 0 || ty < 0 || tx >= mapWidth || ty >= mapHeight) return null;
      return {x: tx, y: ty};
    }

    function applyPaint(ev, eraseOverride) {
      const t = tileFromEvent(ev);
      if (!t) return;
      const erase = eraseOverride ?? (paintMode === 'erase');
      const newVal = erase ? 0 : 1;
      if (isPathMap[t.y][t.x] === newVal) return;
      isPathMap[t.y][t.x] = newVal;
      updateMasksAround(t.x, t.y);
      renderAll();
    }

    // --- Event wiring ---
    newMapBtn.addEventListener('click', () => {
      const w = clamp(parseInt(widthInput.value || '0', 10), 1, MAX_TILES);
      const h = clamp(parseInt(heightInput.value || '0', 10), 1, MAX_TILES);
      mapWidth = w; mapHeight = h;
      widthInput.value = w; heightInput.value = h;
      allocMaps(mapWidth, mapHeight);
      resizeCanvas();
      renderAll();
    });

    zoomSlider.addEventListener('input', () => {
      zoom = clamp(parseInt(zoomSlider.value, 10), 1, 6);
      resizeCanvas();
      renderAll();
    });

    paintBtn.addEventListener('click', () => {
      paintMode = 'paint';
      paintBtn.classList.add('selected');
      eraseBtn.classList.remove('selected');
    });

    eraseBtn.addEventListener('click', () => {
      paintMode = 'erase';
      eraseBtn.classList.add('selected');
      paintBtn.classList.remove('selected');
    });

    canvas.addEventListener('mousedown', ev => {
      ev.preventDefault();
      const erase = (ev.button === 2) || (paintMode === 'erase');
      applyPaint(ev, erase);
      drawing = true;
    });

    let drawing = false;
    canvas.addEventListener('mousemove', ev => {
      if (drawing) {
        const erase = (ev.buttons & 2) || (paintMode === 'erase');
        applyPaint(ev, erase);
      }
    });
    window.addEventListener('mouseup', () => { drawing = false; });
    canvas.addEventListener('contextmenu', ev => ev.preventDefault());

    exportBtn.addEventListener('click', () => {
      const tiles = [];
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          tiles.push(maskMap[y][x] | 0);
        }
      }
      const data = { width: mapWidth, height: mapHeight, tiles };
      exportArea.value = JSON.stringify(data, null, 2);
    });

    importBtn.addEventListener('click', () => {
      try {
        const data = JSON.parse(exportArea.value);
        const w = clamp(parseInt(data.width, 10) || 0, 1, MAX_TILES);
        const h = clamp(parseInt(data.height, 10) || 0, 1, MAX_TILES);
        const tiles = Array.isArray(data.tiles) ? data.tiles : [];
        if (tiles.length !== w * h) {
          alert('tiles.length does not match width×height');
          return;
        }
        mapWidth = w; mapHeight = h;
        widthInput.value = w; heightInput.value = h;
        allocMaps(mapWidth, mapHeight);
        let i = 0;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const mask = clamp(tiles[i++] | 0, 0, 15);
            maskMap[y][x] = mask;
            isPathMap[y][x] = mask ? 1 : 0;
          }
        }
        resizeCanvas();
        renderAll();
      } catch (e) {
        alert('Bad JSON: ' + e.message);
      }
    });

    // --- Init ---
    createQuarterMasks();
    allocMaps(mapWidth, mapHeight);
    resizeCanvas();
    renderAll();
  </script>
</body>
</html>
