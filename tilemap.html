<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Auto Path Tilemap Editor (8×8, 64×64)</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 0;
      background: #111;
      color: #eee;
      display: flex;
      height: 100vh;
    }
    #sidebar {
      width: 260px;
      padding: 16px;
      box-sizing: border-box;
      background: #1b1b1b;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      box-sizing: border-box;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 18px;
    }
    fieldset {
      border: 1px solid #444;
      border-radius: 6px;
      padding: 8px 10px 10px;
    }
    legend {
      padding: 0 4px;
      font-size: 12px;
      color: #aaa;
    }
    label {
      font-size: 13px;
    }
    input[type="number"] {
      width: 70px;
      padding: 2px 4px;
      margin-right: 4px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #222;
      color: #eee;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #333;
      color: #eee;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover {
      background: #444;
    }
    button.selected {
      outline: 2px solid #fff;
    }
    #modeButtons {
      display: flex;
      gap: 6px;
      margin-top: 6px;
      flex-wrap: wrap;
    }
    #canvasWrapper {
      flex: 1;
      overflow: auto;
      border: 1px solid #333;
      background: #000;
    }
    #mapCanvas {
      image-rendering: pixelated;
      display: block;
    }
    #exportArea {
      width: 100%;
      height: 140px;
      box-sizing: border-box;
      background: #111;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      font-family: monospace;
      font-size: 11px;
      padding: 6px;
      resize: vertical;
    }
    small {
      color: #999;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h1>Auto Path Editor</h1>
    <small>
      Tiles are 8×8. Map up to 64×64 tiles.<br>
      You paint a <b>path mask</b>; the editor chooses one of 16 path tiles
      (based on N/E/S/W neighbours) so you can draw continuous paths.
    </small>

    <fieldset>
      <legend>Map Size (tiles)</legend>
      <div>
        <label>Width:
          <input type="number" id="widthInput" min="1" max="64" value="16">
        </label>
      </div>
      <div style="margin-top:4px;">
        <label>Height:
          <input type="number" id="heightInput" min="1" max="64" value="16">
        </label>
      </div>
      <div style="margin-top:8px;">
        <button id="newMapBtn">New Map</button>
      </div>
      <small>Max 64×64 tiles. New map clears everything.</small>
    </fieldset>

    <fieldset>
      <legend>Paint Mode</legend>
      <div id="modeButtons">
        <button id="modePathBtn" class="selected">Paint Path</button>
        <button id="modeEraseBtn">Erase</button>
      </div>
      <small>
        Left-click to paint / erase. Drag to draw.<br>
        The tile graphic changes automatically as neighbours change.
      </small>
    </fieldset>

    <fieldset>
      <legend>Zoom</legend>
      <input type="range" id="zoomSlider" min="1" max="6" value="4">
      <small>Controls on-screen size of each 8×8 tile.</small>
    </fieldset>

    <fieldset>
      <legend>Export / Import</legend>
      <div style="display:flex; gap:4px; margin-bottom:6px;">
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn">Import JSON</button>
      </div>
      <textarea id="exportArea" spellcheck="false"></textarea>
      <small>
        Export format:<br>
        { "width", "height", "tiles": [mask0, mask1, ...] }<br>
        Each mask is a 4‑bit value (N,E,S,W) 0–15. 0 = empty.
      </small>
    </fieldset>
  </div>

  <div id="main">
    <div id="canvasWrapper">
      <canvas id="mapCanvas"></canvas>
    </div>
  </div>

  <script>
    // --- Config ---
    const MAX_TILES = 64;
    const TILE_PIXELS = 8;      // logical 8×8 tile
    const GRID_COLOR = '#ff00ff';
    const BG_COLOR = '#ffffff';
    const PATH_COLOR = '#ff4b81';

    // --- State ---
    let mapWidth = 16;
    let mapHeight = 16;
    let zoom = 4;              // size of one logical pixel
    let maskMap = [];          // 2D: [y][x] 0–15 (bitmask N,E,S,W)
    let isPathMap = [];        // 2D: [y][x] 0/1 for quick neighbour checks
    let paintMode = 'path';    // 'path' or 'erase'

    // --- DOM ---
    const widthInput  = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const newMapBtn   = document.getElementById('newMapBtn');
    const zoomSlider  = document.getElementById('zoomSlider');
    const exportBtn   = document.getElementById('exportBtn');
    const importBtn   = document.getElementById('importBtn');
    const exportArea  = document.getElementById('exportArea');
    const modePathBtn = document.getElementById('modePathBtn');
    const modeEraseBtn= document.getElementById('modeEraseBtn');
    const canvas      = document.getElementById('mapCanvas');
    const ctx         = canvas.getContext('2d');

    // --- Helpers ---
    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function createEmptyMaps(w, h) {
      maskMap = [];
      isPathMap = [];
      for (let y = 0; y < h; y++) {
        const rowMask = new Array(w).fill(0);
        const rowPath = new Array(w).fill(0);
        maskMap.push(rowMask);
        isPathMap.push(rowPath);
      }
    }

    function resizeCanvas() {
      const tileSize = TILE_PIXELS * zoom;
      canvas.width = mapWidth * tileSize;
      canvas.height = mapHeight * tileSize;
    }

    function computeMask(x, y) {
      if (!isPathMap[y][x]) {
        return 0;
      }
      let mask = 0;
      // bit 0: North
      if (y > 0 && isPathMap[y - 1][x]) mask |= 1;
      // bit 1: East
      if (x < mapWidth - 1 && isPathMap[y][x + 1]) mask |= 2;
      // bit 2: South
      if (y < mapHeight - 1 && isPathMap[y + 1][x]) mask |= 4;
      // bit 3: West
      if (x > 0 && isPathMap[y][x - 1]) mask |= 8;
      return mask;
    }

    function updateMasksAround(x, y) {
      const coords = [
        [x, y],
        [x, y - 1],
        [x + 1, y],
        [x, y + 1],
        [x - 1, y]
      ];
      for (const [cx, cy] of coords) {
        if (cx < 0 || cy < 0 || cx >= mapWidth || cy >= mapHeight) continue;
        maskMap[cy][cx] = computeMask(cx, cy);
      }
    }

    function drawGrid() {
      const tileSize = TILE_PIXELS * zoom;
      ctx.strokeStyle = GRID_COLOR;
      ctx.lineWidth = 1;

      ctx.beginPath();
      for (let x = 0; x <= mapWidth; x++) {
        const px = x * tileSize + 0.5;
        ctx.moveTo(px, 0);
        ctx.lineTo(px, canvas.height);
      }
      for (let y = 0; y <= mapHeight; y++) {
        const py = y * tileSize + 0.5;
        ctx.moveTo(0, py);
        ctx.lineTo(canvas.width, py);
      }
      ctx.stroke();
    }

    function drawPathTile(tx, ty, mask) {
      if (mask === 0) return;
      const tileSize = TILE_PIXELS * zoom;
      const x0 = tx * tileSize;
      const y0 = ty * tileSize;
      const cx = x0 + tileSize / 2;
      const cy = y0 + tileSize / 2;

      ctx.fillStyle = PATH_COLOR;

      // If this tile connects in all four directions (N+E+S+W),
      // render it as a completely filled tile (solid pink),
      // like the "full" tile in your 16‑tile set.
      if (mask === 15) {
        ctx.fillRect(x0, y0, tileSize, tileSize);
        return;
      }

      const thickness = tileSize * 0.6; // width of the path
      const halfT = thickness / 2;

      // Center blob
      ctx.fillRect(cx - halfT, cy - halfT, thickness, thickness);

      // Arms based on mask: North (1), East (2), South (4), West (8)
      if (mask & 1) { // North
        ctx.fillRect(cx - halfT, y0, thickness, tileSize / 2);
      }
      if (mask & 2) { // East
        ctx.fillRect(cx, cy - halfT, tileSize / 2, thickness);
      }
      if (mask & 4) { // South
        ctx.fillRect(cx - halfT, cy, thickness, tileSize / 2);
      }
      if (mask & 8) { // West
        ctx.fillRect(x0, cy - halfT, tileSize / 2, thickness);
      }
    }

    function renderMap() {
      const tileSize = TILE_PIXELS * zoom;

      // background
      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          const mask = maskMap[y][x];
          if (mask) {
            drawPathTile(x, y, mask);
          }
        }
      }

      drawGrid();
    }

    function toCanvasCoords(ev) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (ev.clientX - rect.left) * scaleX,
        y: (ev.clientY - rect.top) * scaleY
      };
    }

    function handlePaint(ev) {
      const pos = toCanvasCoords(ev);
      const tileSize = TILE_PIXELS * zoom;
      const tx = Math.floor(pos.x / tileSize);
      const ty = Math.floor(pos.y / tileSize);

      if (tx < 0 || ty < 0 || tx >= mapWidth || ty >= mapHeight) return;

      const newIsPath = (paintMode === 'path') ? 1 : 0;
      if (isPathMap[ty][tx] === newIsPath) return; // no change

      isPathMap[ty][tx] = newIsPath;
      updateMasksAround(tx, ty);
      renderMap();
    }

    // --- Event wiring ---
    newMapBtn.addEventListener('click', () => {
      const w = clamp(parseInt(widthInput.value || '0', 10), 1, MAX_TILES);
      const h = clamp(parseInt(heightInput.value || '0', 10), 1, MAX_TILES);
      mapWidth = w;
      mapHeight = h;
      widthInput.value = w;
      heightInput.value = h;

      createEmptyMaps(mapWidth, mapHeight);
      resizeCanvas();
      renderMap();
    });

    zoomSlider.addEventListener('input', () => {
      zoom = clamp(parseInt(zoomSlider.value, 10), 1, 6);
      resizeCanvas();
      renderMap();
    });

    canvas.addEventListener('mousedown', ev => {
      ev.preventDefault();
      handlePaint(ev);
    });

    canvas.addEventListener('mousemove', ev => {
      if (ev.buttons & 1) {
        handlePaint(ev);
      }
    });

    canvas.addEventListener('contextmenu', ev => ev.preventDefault());

    exportBtn.addEventListener('click', () => {
      const tiles = [];
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          tiles.push(maskMap[y][x] | 0);
        }
      }
      const data = {
        width: mapWidth,
        height: mapHeight,
        tiles
      };
      exportArea.value = JSON.stringify(data, null, 2);
    });

    importBtn.addEventListener('click', () => {
      try {
        const data = JSON.parse(exportArea.value);
        const w = clamp(parseInt(data.width, 10) || 0, 1, MAX_TILES);
        const h = clamp(parseInt(data.height, 10) || 0, 1, MAX_TILES);
        const tiles = Array.isArray(data.tiles) ? data.tiles : [];

        if (tiles.length !== w * h) {
          alert('Tile data length does not match width×height.');
          return;
        }

        mapWidth = w;
        mapHeight = h;
        widthInput.value = w;
        heightInput.value = h;

        createEmptyMaps(mapWidth, mapHeight);
        let i = 0;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const mask = clamp(tiles[i++] | 0, 0, 15);
            maskMap[y][x] = mask;
            isPathMap[y][x] = mask ? 1 : 0;
          }
        }

        resizeCanvas();
        renderMap();
      } catch (e) {
        alert('Failed to parse JSON.\n\n' + e.message);
      }
    });

    // Paint mode toggles
    function setMode(mode) {
      paintMode = mode;
      if (mode === 'path') {
        modePathBtn.classList.add('selected');
        modeEraseBtn.classList.remove('selected');
      } else {
        modeEraseBtn.classList.add('selected');
        modePathBtn.classList.remove('selected');
      }
    }

    modePathBtn.addEventListener('click', () => setMode('path'));
    modeEraseBtn.addEventListener('click', () => setMode('erase'));

    // --- Init ---
    createEmptyMaps(mapWidth, mapHeight);
    resizeCanvas();
    renderMap();
  </script>
</body>
</html>

