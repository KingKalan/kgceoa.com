<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Auto Path Tilemap Editor (8×8, 64×64)</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 0;
      background: #111;
      color: #eee;
      display: flex;
      height: 100vh;
    }
    #sidebar {
      width: 260px;
      padding: 16px;
      box-sizing: border-box;
      background: #1b1b1b;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      box-sizing: border-box;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 18px;
    }
    fieldset {
      border: 1px solid #444;
      border-radius: 6px;
      padding: 8px 10px 10px;
    }
    legend {
      padding: 0 4px;
      font-size: 12px;
      color: #aaa;
    }
    label {
      font-size: 13px;
    }
    input[type="number"] {
      width: 70px;
      padding: 2px 4px;
      margin-right: 4px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #222;
      color: #eee;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #333;
      color: #eee;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover {
      background: #444;
    }
    button.selected {
      outline: 2px solid #fff;
    }
    #modeButtons {
      display: flex;
      gap: 6px;
      margin-top: 6px;
      flex-wrap: wrap;
    }
    #canvasWrapper {
      flex: 1;
      overflow: auto;
      border: 1px solid #333;
      background: #000;
    }
    #mapCanvas {
      image-rendering: pixelated;
      display: block;
    }
    #exportArea {
      width: 100%;
      height: 140px;
      box-sizing: border-box;
      background: #111;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      font-family: monospace;
      font-size: 11px;
      padding: 6px;
      resize: vertical;
    }
    small {
      color: #999;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h1>Auto Path Editor</h1>
    <small>
      Tiles are 8×8. Map up to 64×64 tiles.<br>
      You just paint where the path is.<br>
      Internally each path tile has a 4‑bit NESW mask (0–15).
    </small>

    <fieldset>
      <legend>Map Size (tiles)</legend>
      <div>
        <label>Width:
          <input type="number" id="widthInput" min="1" max="64" value="16">
        </label>
      </div>
      <div style="margin-top:4px;">
        <label>Height:
          <input type="number" id="heightInput" min="1" max="64" value="16">
        </label>
      </div>
      <div style="margin-top:8px;">
        <button id="newMapBtn">New Map</button>
      </div>
      <small>New map clears all path data.</small>
    </fieldset>

    <fieldset>
      <legend>Paint Mode</legend>
      <div id="modeButtons">
        <button id="modePathBtn" class="selected">Paint Path</button>
        <button id="modeEraseBtn">Erase</button>
      </div>
      <small>Left‑click / drag to paint or erase tiles.</small>
    </fieldset>

    <fieldset>
      <legend>Zoom</legend>
      <input type="range" id="zoomSlider" min="1" max="6" value="4">
      <small>Controls on‑screen size of each 8×8 tile.</small>
    </fieldset>

    <fieldset>
      <legend>Export / Import</legend>
      <div style="display:flex; gap:4px; margin-bottom:6px;">
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn">Import JSON</button>
      </div>
      <textarea id="exportArea" spellcheck="false"></textarea>
      <small>
        Exported format:<br>
        { "width", "height", "tiles": [mask0, mask1, ...] }<br>
        Each tile is 0–15 (bitmask N,E,S,W).
      </small>
    </fieldset>
  </div>

  <div id="main">
    <div id="canvasWrapper">
      <canvas id="mapCanvas"></canvas>
    </div>
  </div>

  <script>
    // --- Config ---
    const MAX_TILES   = 64;
    const TILE_PIXELS = 8;              // logical 8×8 tile
    const GRID_COLOR  = '#ff00ff';
    const BG_COLOR    = '#ffffff';
    const PATH_COLOR  = '#ff4b81';

    // --- State ---
    let mapWidth  = 16;
    let mapHeight = 16;
    let zoom      = 4;                  // scale factor for each logical pixel
    let isPathMap = [];                 // [y][x] 0/1, whether this tile is part of the path
    let maskMap   = [];                 // [y][x] 0–15 NESW mask
    let paintMode = 'path';             // 'path' or 'erase'

    // --- DOM ---
    const widthInput   = document.getElementById('widthInput');
    const heightInput  = document.getElementById('heightInput');
    const newMapBtn    = document.getElementById('newMapBtn');
    const zoomSlider   = document.getElementById('zoomSlider');
    const exportBtn    = document.getElementById('exportBtn');
    const importBtn    = document.getElementById('importBtn');
    const exportArea   = document.getElementById('exportArea');
    const modePathBtn  = document.getElementById('modePathBtn');
    const modeEraseBtn = document.getElementById('modeEraseBtn');
    const canvas       = document.getElementById('mapCanvas');
    const ctx          = canvas.getContext('2d');

    // --- Helpers ---
    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function allocMaps(w, h) {
      isPathMap = [];
      maskMap   = [];
      for (let y = 0; y < h; y++) {
        const rowPath = new Array(w).fill(0);
        const rowMask = new Array(w).fill(0);
        isPathMap.push(rowPath);
        maskMap.push(rowMask);
      }
    }

    function resizeCanvas() {
      const tileSize = TILE_PIXELS * zoom;
      canvas.width  = mapWidth * tileSize;
      canvas.height = mapHeight * tileSize;
    }

    // Compute NESW bitmask for a single tile
    // bit0=N, bit1=E, bit2=S, bit3=W
    function computeMask(x, y) {
      if (!isPathMap[y][x]) return 0;
      let mask = 0;
      if (y > 0 && isPathMap[y - 1][x])           mask |= 1; // N
      if (x < mapWidth  - 1 && isPathMap[y][x+1]) mask |= 2; // E
      if (y < mapHeight - 1 && isPathMap[y + 1][x]) mask |= 4; // S
      if (x > 0 && isPathMap[y][x - 1])           mask |= 8; // W
      return mask;
    }

    // Recompute mask for (x,y) and its four 4‑way neighbours
    function updateMasksAround(x, y) {
      const coords = [
        [x, y],
        [x, y - 1],
        [x + 1, y],
        [x, y + 1],
        [x - 1, y]
      ];
      for (const [cx, cy] of coords) {
        if (cx < 0 || cy < 0 || cx >= mapWidth || cy >= mapHeight) continue;
        maskMap[cy][cx] = computeMask(cx, cy);
      }
    }

    // Simple renderer: any non‑zero mask becomes a solid pink tile.
    // The *shape* is handled later in your engine based on maskMap; here
    // you only care about "path exists here" vs empty.
    function drawPathTile(tx, ty, mask) {
      if (mask === 0) return;
      const tileSize = TILE_PIXELS * zoom;
      const x0 = tx * tileSize;
      const y0 = ty * tileSize;
      ctx.fillStyle = PATH_COLOR;
      ctx.fillRect(x0, y0, tileSize, tileSize);
    }

    function drawGrid() {
      const tileSize = TILE_PIXELS * zoom;
      ctx.strokeStyle = GRID_COLOR;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= mapWidth; x++) {
        const px = x * tileSize + 0.5;
        ctx.moveTo(px, 0);
        ctx.lineTo(px, canvas.height);
      }
      for (let y = 0; y <= mapHeight; y++) {
        const py = y * tileSize + 0.5;
        ctx.moveTo(0, py);
        ctx.lineTo(canvas.width, py);
      }
      ctx.stroke();
    }

    function renderMap() {
      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          const mask = maskMap[y][x];
          if (mask) {
            drawPathTile(x, y, mask);
          }
        }
      }

      drawGrid();
    }

    function canvasToTile(ev) {
      const rect   = canvas.getBoundingClientRect();
      const scaleX = canvas.width  / rect.width;
      const scaleY = canvas.height / rect.height;
      const px = (ev.clientX - rect.left) * scaleX;
      const py = (ev.clientY - rect.top)  * scaleY;
      const tileSize = TILE_PIXELS * zoom;
      const tx = Math.floor(px / tileSize);
      const ty = Math.floor(py / tileSize);
      if (tx < 0 || ty < 0 || tx >= mapWidth || ty >= mapHeight) {
        return null;
      }
      return { x: tx, y: ty };
    }

    function applyPaint(ev) {
      const t = canvasToTile(ev);
      if (!t) return;
      const newPath = (paintMode === 'path') ? 1 : 0;
      if (isPathMap[t.y][t.x] === newPath) return;
      isPathMap[t.y][t.x] = newPath;
      updateMasksAround(t.x, t.y);
      renderMap();
    }

    // --- Event wiring ---
    newMapBtn.addEventListener('click', () => {
      const w = clamp(parseInt(widthInput.value  || '0', 10), 1, MAX_TILES);
      const h = clamp(parseInt(heightInput.value || '0', 10), 1, MAX_TILES);
      mapWidth  = w;
      mapHeight = h;
      widthInput.value  = w;
      heightInput.value = h;
      allocMaps(mapWidth, mapHeight);
      resizeCanvas();
      renderMap();
    });

    zoomSlider.addEventListener('input', () => {
      zoom = clamp(parseInt(zoomSlider.value, 10), 1, 6);
      resizeCanvas();
      renderMap();
    });

    canvas.addEventListener('mousedown', (ev) => {
      ev.preventDefault();
      applyPaint(ev);
    });

    canvas.addEventListener('mousemove', (ev) => {
      if (ev.buttons & 1) {
        applyPaint(ev);
      }
    });

    canvas.addEventListener('contextmenu', ev => ev.preventDefault());

    exportBtn.addEventListener('click', () => {
      const tiles = [];
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          tiles.push(maskMap[y][x] | 0);
        }
      }
      const data = { width: mapWidth, height: mapHeight, tiles };
      exportArea.value = JSON.stringify(data, null, 2);
    });

    importBtn.addEventListener('click', () => {
      try {
        const data  = JSON.parse(exportArea.value);
        const w = clamp(parseInt(data.width, 10)  || 0, 1, MAX_TILES);
        const h = clamp(parseInt(data.height, 10) || 0, 1, MAX_TILES);
        const tiles = Array.isArray(data.tiles) ? data.tiles : [];
        if (tiles.length !== w * h) {
          alert('Tile data length does not match width×height.');
          return;
        }

        mapWidth  = w;
        mapHeight = h;
        widthInput.value  = w;
        heightInput.value = h;

        allocMaps(mapWidth, mapHeight);
        let i = 0;
        for (let y = 0; y < mapHeight; y++) {
          for (let x = 0; x < mapWidth; x++) {
            const mask = clamp(tiles[i++] | 0, 0, 15);
            maskMap[y][x]   = mask;
            isPathMap[y][x] = mask ? 1 : 0;
          }
        }

        resizeCanvas();
        renderMap();
      } catch (e) {
        alert('Failed to parse JSON.\n\n' + e.message);
      }
    });

    function setMode(mode) {
      paintMode = mode;
      if (mode === 'path') {
        modePathBtn.classList.add('selected');
        modeEraseBtn.classList.remove('selected');
      } else {
        modeEraseBtn.classList.add('selected');
        modePathBtn.classList.remove('selected');
      }
    }

    modePathBtn.addEventListener('click', () => setMode('path'));
    modeEraseBtn.addEventListener('click', () => setMode('erase'));

    // --- Init ---
    allocMaps(mapWidth, mapHeight);
    resizeCanvas();
    renderMap();
  </script>
</body>
</html>
